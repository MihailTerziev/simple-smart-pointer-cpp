# simple-smart-pointer-cpp
This is simple implementation of a smart pointer class. It allows save usage of dynamic memory. The class encapsulates raw pointer logic and deallocates resources automatically. Instances can be copyied, copy-assigned, moved and move-assigned so that working with them would be flexible and convenient for the user.

However, dynamic instantiating of the class should not be done, as there will be memory leak, if the user doesn't call the destructor manually. Purpose of the class is to encapsulate pointer to dynamic memory and free it when not needed anymore, so it should be located on the stack. Original c++11 standard smart pointers are instantiated on the stack, but point to dynamic memory. Their destructor deallocates the memory and then the compiler frees the instance on the stack. That way it takes care of everything, otherwise it would be redundant and unsafe.

This implementation of smart pointer knows when a copy is made. Making a copy means another instance of the class, in which the encapsulated pointer refers to the same chunk of memory as the original's one. So when the compiler calls the destructor of the original's instance, it will deallocate the memory and will do nothing when the destructor of a copy is called, so that second deallocation of already freed memory, which will cause memory leak, can't be done.

What about base pointer to derived classes? The implementation doesn't change the regular rules of how to use pointers with inheritance. If derived classes use polymorphism, this means base class has virtual member functions and when trying to use them through the pointer class, the output will always be the correct overridden function called. Its up to the user to know if class types are compatible, because there is no RTC (Runtime Type Checking) logic implemented into the smart pointer class, as this would indicate bad design.

Instance of the class can be constructed with or directly assigned to nullptr. Because of the std::nullptr_t type the encapsulated pointer can point at nothing. This makes thing even better, but there is a risk of errors that way, so some guarding logic is put into the basic pointer operations in the class. It knows when the pointer is nullptr, so if it's dereferenced or operator-> is used, a runtime-error would be thrown and the program will stop.

There is also overloaded version of the smart pointer class for arrays of type T[]. When using a pointer there is no way to know if it refers to a single value in the memory or multiple values. So this version will help with using pointers to arrays and it shall dealocate them safely. Ofcourse if we use instance of the class for single value everything will work correctly, until the deallocation comes. Again it is up to the user to watch out for this, but the rules are simple.
